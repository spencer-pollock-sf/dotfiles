#!/usr/bin/env python3
# encoding: utf-8
#
#    ^...^ 
#   / o,o \
#   |):::(|
# ====w=w====
# By: Spencer Pollock <spencer at spollock dot ca>
# 

'''
Python Standard Libraries
'''

import argparse
import asyncio
import configparser
import datetime
import glob
import json
import hmac
import hashlib
import logging
import multiprocessing
import random
import re
import shlex
import smtplib
import subprocess
import sys
import threading
import time
import os
import os
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

'''
Libraries
'''
import psutil
from dotenv import load_dotenv

'''
Global variables
'''
DEBUG = False
VERBOSE = False

DEFAULT_EMAIL_LIST = ''
TO_EMAIL = None
CC_EMAIL = None
EMAIL_SUBJECT = None
EMAIL_BODY = None

load_dotenv()

'''
Functions
'''
# def lex(ln) :
#     ''' 
#     https://stackoverflow.com/a/68496536/5078905
#     Lexing :
#     1. Generate regex for each token type :
#        a) tokens that are python sequence literals.
#        b) tokens that are whitespace delimited. 
#        There is only one 'layer' of lexing,i.e in case of sequences within sequences, the entire outermost sequence is one token.
#      2. Remove tokens that fall into comments
#      3. Return list of tokens
#     '''

#     token_delims = '\'\'""{}()[]'
#     regex_subexperessions = [] 
#     for i in range(0,len(token_delims),2) :
#         regex_subexperessions.append(r'\{0}[^{1}]*\{1}'.format(token_delims[i],token_delims[i+1])) # Regex for each sequence delimiter pair
#     regex = '|'.join(regex_subexperessions) + r'|\S+'                                       # Combine with regex for whitespace delimitation on the remainder

#     tokens = re.findall(regex,ln)
#     comment = False
#     for token in  tokens :
#         if comment : tokens.remove(token)
#         elif token[0] == '#' : comment = True

#     return tokens

def sys_info():
    status = False
    output = ''
    # gives a single float value
    if (psutil.cpu_percent() > 70):
        status = True
    cpu = 'CPU: {}'.format(psutil.cpu_percent())
    output += cpu + '\n'
    logging.log(logging.INFO, cpu)

    if (psutil.virtual_memory().percent > 70):
        status = True
    mem = 'MEM: {}/{} MB'.format(psutil.virtual_memory().active>>20, psutil.virtual_memory().total>>20)
    output += mem + '\n'
    logging.log(logging.INFO, mem)

    if (psutil.disk_usage('/').percent > 70):
        status = True
    dsk = 'DSK: total: {}GB, used {}GB, free {}GB'.format(psutil.disk_usage('/')[0]>>30, psutil.disk_usage('/')[1]>>30, psutil.disk_usage('/')[2]>>30)
    output += dsk + '\n'
    logging.log(logging.INFO, dsk)

    return status, output

def send_email(email_to_list=None, email_cc_list=None, email_subject=None, email_body=None):
    '''
    email_to_list : str - comma separated email list
    CQ
    '''
    ERROR_MSG = ('\033[1;38;5;196m'+'ERROR: '+'\033[0m')
    LGREEN_2 = '\033[38;5;46m'
    NC = '\033[0m'

    COMMASPACE = ', '
    gmail_user = os.getenv('GMAIL_USER')
    gmail_password = os.getenv('GMAIL_PASSWORD')

    #nowtime = get_todays_datetime()
    nowtime = datetime.datetime.now()

    from_email = gmail_user

    target_email_s = email_to_list
    if target_email_s == False or target_email_s == None or target_email_s == '':
        email_to_list = DEFAULT_EMAIL_LIST
    target_email_s = email_to_list

    msg = MIMEMultipart()
    msg['Subject'] = '{}'.format(email_subject)
    msg['From']    = from_email
    msg['To']      = TO_EMAIL
    msg['CC']      = CC_EMAIL

    # logfile = os.getenv('PROCESS_LOG_FILE')
    # with open(os.path.abspath(logfile), 'r') as file:
    #     logfile_contents = file.read()
    # if logfile_contents == None:
    #     logfile_contents = 'Could not read logfile from {}'.format(logfile)
    # email_msg_content = 'Last logs: \n{}'.format(logfile_contents)
    email_msg_content = EMAIL_BODY

    msg_content = str(email_msg_content)

    msg_text = MIMEText(msg_content)
    msg.attach(msg_text)

    # Send the email via our own SMTP server
    try:
        s = smtplib.SMTP_SSL('smtp.gmail.com', 465)
        s.ehlo()
        logging.log(logging.INFO, 'logging into wrsc-vm@whitecap')
        s.login(gmail_user, gmail_password)
        s.sendmail(from_email, email_to_list, msg.as_string())
        s.quit()
        logging.log(logging.INFO, LGREEN_2 + "-----------------------------------------------" + NC)
        logging.log(logging.INFO, LGREEN_2 + " Sent Email(s) to " + str(email_to_list) + NC)
        logging.log(logging.INFO, LGREEN_2 + "-----------------------------------------------" + NC)
    except Exception as e:
        logging.log(logging.ERROR, ERROR_MSG + "Failed to send email(s)...")
        logging.log(logging.ERROR, str(e))

def discord_webhook():
    '''
    Warning The shlex module is only designed for Unix shells.
    The quote() function is not guaranteed to be correct on non-POSIX compliant shells or shells from other operating systems such as Windows. Executing commands quoted by this module on such shells can open up the possibility of a command injection vulnerability.

    Consider using functions that pass command arguments with lists such as subprocess.run() with shell=False.
    '''
    # not_remote_command = 'ssh home {}'.format(shlex.quote(command))
    global EMAIL_BODY
    '''
    curl --location --request POST 'https://discord.com/api/webhooks/922719415072591954/EDlx5nUvq3lWx6Xglu9SICIuKuCs3lGjEDoKeJpxJtiqrytUH7NITj6mmhSywGpTUkos' \
    --header 'Content-Type: application/json' \
    --data-raw '{
        "content": "CPU: 0.0\nMEM: 2382/3932 MB\nDSK: total: 250GB, used 66GB, free 171GB"
    }'
    '''
    command = 'curl -0 -v -X POST -H \"Expect:\" -H \"Content-Type: application/json\" --data \'{}\' {}'.format(json.dumps({'content': EMAIL_BODY}, indent = 4), os.getenv('DISCORD_WEBHOOK_URL'))
    print (command)
    status, output = subprocess.getstatusoutput(command)
    return status, output

'''
Classes
'''
class ExampleClass:
    def __init__(self):
        pass

'''
Main runners
'''
def get_args():
    '''
    A good Python example script.
    '''
    parser = argparse.ArgumentParser(description='A fancy description goes here for your script.')
    parser.add_argument('--config', dest='configfile', type=str, default='default.cfg', help='Config file to use. Local Global: DEFAULT_CONFIG to \'default.cfg\'.')
    parser.add_argument('--debug', dest='debug', action='store_true', help='Runs debug statements and checks without processing.') # NOTE: to be implemented later
    parser.add_argument('--verbose', dest='verbose', action='store_true', help='Runs the script in verbose mode.') 
    return parser.parse_args()

def main(args):
    '''
    Main function for running.
    '''
    global DEBUG
    global VERBOSE
    global TO_EMAIL
    global CC_EMAIL
    global EMAIL_SUBJECT
    global EMAIL_BODY
    DEBUG = args.debug
    VERBOSE = args.verbose
    if (VERBOSE):
        print ('Verbose is {}'.format(VERBOSE))
        logging.debug('Verbose is {}'.format(VERBOSE))
    if (args.configfile == 'default.cfg'):
        config = configparser.ConfigParser()
        config.read(os.path.abspath(os.path.join(os.path.dirname(__file__), 'default.cfg')))
    else:
        config = configparser.ConfigParser()
        config.read(os.path.abspath(os.path.join(os.path.dirname(__file__), args.configfile)))
    # Start main
    status, output = sys_info()
    TO_EMAIL = config['DEFAULT']['TO_EMAIL']
    CC_EMAIL = config['DEFAULT']['CC_EMAIL']
    EMAIL_SUBJECT = config['DEFAULT']['EMAIL_SUBJECT']
    EMAIL_BODY = config['DEFAULT']['EMAIL_BODY'].format(output)
    if status and not DEBUG:
        send_email(email_to_list=TO_EMAIL, email_cc_list=CC_EMAIL, email_subject=EMAIL_SUBJECT, email_body=EMAIL_BODY)
    logging.log(logging.INFO, "[**] Status, Output:")
    logging.log(logging.INFO, status)
    logging.log(logging.INFO, output)
    status, output = discord_webhook()
    logging.log(logging.INFO, "[**] Status, Output:")
    logging.log(logging.INFO, status)
    logging.log(logging.INFO, output)
    # End main
    return 0

if __name__ == '__main__':
    logging.basicConfig(format='%(asctime)s - %(message)s', filename='sys_info.log', level=logging.DEBUG, datefmt='%Y-%m-%d %H:%M:%S')
    args = get_args()
    main(args)
    logging.shutdown()
    sys.exit(0)
    # End of file